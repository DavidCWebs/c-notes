From af5da7ed6b9dfcaa3674b3c672ff0ae046ace563 Mon Sep 17 00:00:00 2001
From: David Egan <david@carawebs.com>
Date: Mon, 23 Sep 2019 20:43:57 +0100
Subject: [PATCH 1/2] First commit

---
 README.md           |  3 ++
 flags/Makefile      |  5 ++++
 flags/main.c        | 61 +++++++++++++++++++++++++++++++++++++
 initArray/Makefile  |  5 ++++
 initArray/main.c    | 24 +++++++++++++++
 programme-design.md | 27 +++++++++++++++++
 read-file-fread.md  | 57 +++++++++++++++++++++++++++++++++++
 rectangle/Makefile  |  5 ++++
 rectangle/main.c    | 47 +++++++++++++++++++++++++++++
 squares/Makefile    |  5 ++++
 squares/main.c      | 28 +++++++++++++++++
 typedef-structs.md  | 86 +++++++++++++++++++++++++++++++++++++++++++++++++++++
 12 files changed, 353 insertions(+)
 create mode 100644 README.md
 create mode 100644 flags/Makefile
 create mode 100644 flags/main.c
 create mode 100644 initArray/Makefile
 create mode 100644 initArray/main.c
 create mode 100644 programme-design.md
 create mode 100644 read-file-fread.md
 create mode 100644 rectangle/Makefile
 create mode 100644 rectangle/main.c
 create mode 100644 squares/Makefile
 create mode 100644 squares/main.c
 create mode 100644 typedef-structs.md

diff --git a/README.md b/README.md
new file mode 100644
index 0000000..0cfdd3b
--- /dev/null
+++ b/README.md
@@ -0,0 +1,3 @@
+C Programming Notes
+===================
+Notes and some code examples.
diff --git a/flags/Makefile b/flags/Makefile
new file mode 100644
index 0000000..d671ffa
--- /dev/null
+++ b/flags/Makefile
@@ -0,0 +1,5 @@
+SOURCES:= $(wildcard *.c) $(wildcard *.h)
+OBJECTS:= $(wildcard *.c)
+OUT:= bin/main
+main: $(SOURCES)
+	cc -W -Wall -o $(OUT) $(OBJECTS)
diff --git a/flags/main.c b/flags/main.c
new file mode 100644
index 0000000..21f70b0
--- /dev/null
+++ b/flags/main.c
@@ -0,0 +1,61 @@
+#include <stdio.h>
+enum flag {
+    DEBUG           = 1,
+    WARNINGS        = 1 << 1,
+    VERBOSE         = 1 << 2,
+    SIMPLE          = 1 << 3,
+    TESTS           = 1 << 4,
+    BUILD           = 1 << 5,
+    MULTI           = 1 << 6,
+    DIST            = 1 << 7
+};
+
+const char *flagnames[]= {
+    "DEBUG",
+    "WARNINGS",
+    "VERBOSE",
+    "SIMPLE",
+    "TESTS",
+    "BUILD",
+    "MULTI",
+    "DIST"
+};
+
+int main()
+{
+    char flags = 0;
+    printf("size of char: %lu\n", sizeof(char));
+    printf("size of unsigned char: %lu\n", sizeof(unsigned char));
+    printf("flags:\t\t%d\n", flags);
+    printf("DEBUG:\t\t%d\n", DEBUG);
+    printf("WARN:\t\t%d\n", WARNINGS);
+    printf("VERBOSE:\t%d\n", VERBOSE);
+    printf("SIMPLE:\t\t%d\n", SIMPLE);
+    printf("TESTS:\t\t%d\n", TESTS);
+    printf("BUILD:\t\t%d\n", BUILD);
+    printf("MULTI:\t\t%d\n", MULTI);
+    printf("DIST:\t\t%d\n", DIST);
+
+    int x = 7;
+    printf("x << 2 = %d\n", x << 1);
+
+    // SET using INCLUSIVE OR
+    flags |= VERBOSE;
+    flags |= SIMPLE;
+    flags |= MULTI;
+    flags |= TESTS;
+
+    for (size_t i = 0; i < 8; i++) {
+        if (flags & (1 << i)) printf("%s is SET\n", flagnames[i]);
+    }
+
+    printf("unsetting...\n");
+
+    // Unset using XOR
+    flags ^= TESTS;
+    for (size_t i = 0; i < 8; i++) {
+        if (flags & (1 << i)) printf("%s is SET\n", flagnames[i]);
+    }
+
+    return 0;
+}
diff --git a/initArray/Makefile b/initArray/Makefile
new file mode 100644
index 0000000..d60de5e
--- /dev/null
+++ b/initArray/Makefile
@@ -0,0 +1,5 @@
+SOURCES:= $(wildcard *.c) $(wildcard *.h)
+OBJECTS:= $(wildcard *.c)
+OUT:= bin/main
+main: $(SOURCES)
+	cc -W -Wall -fsanitize=address -g -o $(OUT) $(OBJECTS)
diff --git a/initArray/main.c b/initArray/main.c
new file mode 100644
index 0000000..cc6042c
--- /dev/null
+++ b/initArray/main.c
@@ -0,0 +1,24 @@
+#include <stdio.h>
+#include <stdlib.h>
+
+#define SIZE 10
+
+int *initArray(size_t size)
+{
+	int *p = malloc(size * sizeof(*p));
+	for (size_t i = 0; i < size; i++) {
+		*(p + i) = (int)i;
+	}
+	return p;
+}
+
+
+int main()
+{
+	int *myArray = initArray(SIZE);
+	for (size_t i = 0; i < SIZE; i++) {
+		printf("%d\n", myArray[i]);
+	}
+	free(myArray);
+	return 0;
+}
diff --git a/programme-design.md b/programme-design.md
new file mode 100644
index 0000000..cb237c6
--- /dev/null
+++ b/programme-design.md
@@ -0,0 +1,27 @@
+---
+title: Seven Steps of Programme Design
+---
+Programme Design
+================
+Seven Design Steps
+------------------
+
+### Algorithm Design
+1. Work through a specific instance
+2. Record specific steps taken in step 1
+3. Generalize steps from step 2
+4. Test the steps
+
+### Code Design
+5. Translate the algorithm determined in steps 1 - 4 to code
+6. Test the programme created in step 5
+7. Debug programme, refine if necessary
+
+Algorithm to Code
+-----------------
+
+### Top Down Design
+Taking large complex pieces and separating into functions is known as top-down design.
+
+### Composability
+The ability to put things together and have them work as expected: __composability__.
diff --git a/read-file-fread.md b/read-file-fread.md
new file mode 100644
index 0000000..070f01d
--- /dev/null
+++ b/read-file-fread.md
@@ -0,0 +1,57 @@
+Reading & Writing to File in C
+==============================
+
+File Pointer
+------------
+### Open a File
+Open a file and associate a stream with it using `fopen()`.
+
+```c
+FILE *fopen(const char *path, const char *mode);
+```
+Opens the file specified by `path` and returns a FILE pointer. The `mode` argument is a string that specifies the mode under which the file is opened:
+
+
+* `r`: Reading, stream positioned at the beginning of the file.
+* `r+`: Reading and writing, stream positioned at the beginning of the file.
+* `w`: Truncate file to zero length or create text file for writing - stream positioned at the beginning of the file.
+* `w+`: Reading and writing - file is created if it does not exist, otherwise it is truncated.  The stream positioned at the beginning of the file.
+* `a`: Appending (writing at end of file) - file is created if it does not exist.  Stream positioned at the end of the file.
+* `a+`: Reading and appending (writing at end of file) - file is created if it does not exist.  The initial file position for reading is at the beginning of the file, but output is always appended to the end of the file.
+
+Returns a file descriptor - low level communication mechanism that is used to access a file (or pipe, or network socket).
+
+On Linux, file descriptors are held in the kernel's global file table. This holds data relating to the inode of the file, access restrictions and byte-offset.
+
+### Closing a File
+`fclose(FILE *stream)` is used to close the specified stream. The act of closing sends buffered data to the OS and writes any buffered output data using `fflush()`. The underlying file descriptor is then closed.
+
+On success, 0 is returned. Otherwise, EOF is returned, and `errno` is set to indicate the error.
+
+`fclose()` can fail for a variety of reasons - for example:
+ 
+* Data cannot be written to the disk drive
+* Network connectivity is lost (in the case of a remote file system)
+
+**Always check the return status of fclose()** - and at least report the error on failure.
+
+On close, if the C library has unwritten data, a system call is made to the kernel to write data. The system call takes a file descriptor
+
+Read a File With fread
+----------------------
+`fread()` is used for reading non-textual data from a file i.e. binary format file.
+
+`fread()` prototype:
+
+```c
+size_t fread (void * ptr, size_t size, size_t nitems, FILE * stream);
+```
+
+Writing to a File
+-----------------
+
+References
+----------
+[*nix file descriptors][1]
+
+[1]: https://en.wikipedia.org/wiki/File_descriptor
diff --git a/rectangle/Makefile b/rectangle/Makefile
new file mode 100644
index 0000000..d60de5e
--- /dev/null
+++ b/rectangle/Makefile
@@ -0,0 +1,5 @@
+SOURCES:= $(wildcard *.c) $(wildcard *.h)
+OBJECTS:= $(wildcard *.c)
+OUT:= bin/main
+main: $(SOURCES)
+	cc -W -Wall -fsanitize=address -g -o $(OUT) $(OBJECTS)
diff --git a/rectangle/main.c b/rectangle/main.c
new file mode 100644
index 0000000..5987cb7
--- /dev/null
+++ b/rectangle/main.c
@@ -0,0 +1,47 @@
+#include <stdio.h>
+#include <stdlib.h>
+
+typedef struct v {
+	int x;
+	int y;
+} Vertex;
+
+typedef struct p {
+	size_t n_vertexes;
+	Vertex *Vertexes;
+} Polygon;
+
+Polygon *makeRectangle(Vertex c1, Vertex c2) {
+	Polygon *a = malloc(sizeof(*a));
+	a->n_vertexes = 4;
+	a->points = malloc(a->num_points * sizeof(*a->points));
+//	printf("%lu\n", sizeof(*a->points) * a->num_points);
+//	printf("%d, %d\n", c1.x, c2.x);
+	
+
+	return a;
+//	polygon_t * answer = malloc(sizeof(*answer));
+//	answer->num_points = 4;
+//	answer->points = malloc(answer->num_points * sizeof(*answer->points));
+//	answer->points[0]   = c1;
+//	answer->points[1].x = c1.x;
+//	answer->points[1].y = c2.y;
+//	answer->points[2]   = c2;
+//	answer->points[3].x = c2.x;
+//	answer->points[3].y = c1.y;
+//	return answer;
+}
+
+int main(void)
+{
+	point_t p1 = {2, 2};
+	point_t p2 = {6, 4};
+	polygon_t *myRect = makeRectangle(p1, p2);
+
+	printf("vertex 1: %d, %d\n", myRect->points[1].x, myRect->points[1].y);
+	printf("vertex 2: %d, %d\n", myRect->points[3].x, myRect->points[3].y);
+
+	free(myRect->points);
+	free(myRect);
+	return 0;
+}
diff --git a/squares/Makefile b/squares/Makefile
new file mode 100644
index 0000000..d60de5e
--- /dev/null
+++ b/squares/Makefile
@@ -0,0 +1,5 @@
+SOURCES:= $(wildcard *.c) $(wildcard *.h)
+OBJECTS:= $(wildcard *.c)
+OUT:= bin/main
+main: $(SOURCES)
+	cc -W -Wall -fsanitize=address -g -o $(OUT) $(OBJECTS)
diff --git a/squares/main.c b/squares/main.c
new file mode 100644
index 0000000..c20dcc4
--- /dev/null
+++ b/squares/main.c
@@ -0,0 +1,28 @@
+#include <stdio.h>
+#include <stdlib.h>
+
+// fprintf to write to a file
+// args: rows, cols, output file
+int main(int argc, char **argv)
+{
+	if (argc != 4) {
+		fprintf(stderr, "Please specify correct arguments:\n%s <start> <end> <output file>\n", *argv);
+		return EXIT_FAILURE;
+	}
+	FILE *fp;
+	if (!(fp = fopen(argv[3], "w"))) {
+		fprintf(stderr, "Can't open %s\n", argv[3]);
+		return EXIT_FAILURE;
+	}
+	int start = atoi(argv[1]);
+	int end = atoi(argv[2]);
+	fprintf(fp, "Squares of integers between %d and %d\n", start, end);
+	for (int i = start; i < end; i++) {
+		fprintf(fp, "%d squared is %d\n", i, i * i);
+	}
+	if (fclose(fp) != 0) {
+		fprintf(stderr, "Could not close file.");
+		return EXIT_FAILURE;
+	};
+	return EXIT_SUCCESS;
+}
diff --git a/typedef-structs.md b/typedef-structs.md
new file mode 100644
index 0000000..f7d891d
--- /dev/null
+++ b/typedef-structs.md
@@ -0,0 +1,86 @@
+Typedef Structs
+===============
+Typedefs are a useful abstraction. They can save typing and define a particular type in a single place in the  codebase. This makes it easier to change the type.
+
+On the other hand, using typedefs obscures your code somewhat - it's not obvious that you're dealing with a typedef'd struct when reading the codebase.
+
+
+Define tag only
+---------------
+
+```c
+struct node_tag {
+	int id;
+	struct node_tag *next;
+};
+
+// Usage:
+int main()
+{
+	struct node_tag first;
+	first.id = 1;
+	...
+}
+```
+
+Define tag, then Define Type Alias
+----------------------------------
+
+```c
+struct node_tag {
+	int id;
+	struct node_tag *next;
+};
+typedef struct node_tag Node;
+
+// Usage:
+int main()
+{
+	// In this case, the struct keyword is unnecessary
+	Node first;
+	first.id = 1;
+	...
+}
+```
+
+Declare & Define Struct in a Single Statement
+---------------------------------------------
+
+```c
+typedef struct node_tag {
+	int id;
+	struct node_tag *next;
+} Node;
+
+// Usage:
+int main()
+{
+	// Usage as above
+	Node first;
+	first.id = 1;
+	...
+}
+```
+
+Typedef with no Tag Declaration
+-------------------------------
+When defined in this way, a struct can't refer to it's own type.
+
+```c
+typedef struct {
+	int id;
+	// Can't refer to this type as in the `next` field above.
+} Node;
+
+// Usage:
+int main()
+{
+	// In this case, the struct keyword is unnecessary
+	Node first;
+	first.id = 1;
+	...
+}
+```
+
+
+
-- 
2.7.4

